% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rasterize_mesh.R
\name{rasterize_mesh}
\alias{rasterize_mesh}
\title{Rasterize an OBJ file}
\usage{
rasterize_mesh(
  mesh,
  filename = NA,
  width = 800,
  height = 800,
  line_info = NULL,
  alpha_line = 1,
  parallel = TRUE,
  fov = 20,
  lookfrom = c(0, 0, 10),
  lookat = NULL,
  camera_up = c(0, 1, 0),
  scale_obj = 1,
  light_info = directional_light(),
  color = "red",
  type = "diffuse",
  background = "black",
  tangent_space_normals = TRUE,
  shadow_map = FALSE,
  shadow_map_bias = 0.001,
  shadow_map_intensity = 0.5,
  shadow_map_dims = NULL,
  ssao = FALSE,
  ssao_intensity = 10,
  ssao_radius = 0.1,
  tonemap = "none",
  debug = "none",
  near_plane = 0.1,
  far_plane = 100,
  culling = "back",
  shader = "default",
  block_size = 4,
  shape = NULL,
  line_offset = 1e-05,
  ortho_dims = c(1, 1),
  bloom = FALSE,
  antialias_lines = TRUE
)
}
\arguments{
\item{mesh}{The mesh object.}

\item{filename}{Default `NULL`. Filename to save the image. If `NULL`, the image will be plotted.}

\item{width}{Default `400`. Width of the rendered image.}

\item{height}{Default `400`. Width of the rendered image.}

\item{line_info}{Default `NULL`. Matrix of line segments to add to the scene. Number of rows must be a multiple of 2.}

\item{parallel}{Default `TRUE`. Whether to use parallel processing.}

\item{fov}{Default `20`. Width of the rendered image.}

\item{lookfrom}{Default `c(0,0,10)`. Camera location.}

\item{lookat}{Default `NULL`. Camera focal position, defaults to the center of the model.}

\item{camera_up}{Default `c(0,1,0)`. Camera up vector.}

\item{scale_obj}{Default `1`. Value to scale size of model.}

\item{color}{Default `darkred`. Color of model if no material file present (or for faces using the default material).}

\item{type}{Default `diffuse`. Shader type. Other options: `vertex` (Gouraud shading), `phong`, and `color` (no lighting).}

\item{background}{Default `white`. Background color.}

\item{tangent_space_normals}{Default `TRUE`.}

\item{shadow_map}{Default `FALSE`.}

\item{shadow_map_bias}{Default `0.005`.}

\item{shadow_map_intensity}{Default `0.5`.}

\item{shadow_map_dims}{Default `NULL`.}

\item{ssao}{Default `FALSE`. Whether to add screen-space ambient occlusion (SSAO) to the render.}

\item{ssao_intensity}{Default `10`. Intensity of the shadow map.}

\item{ssao_radius}{Default `0.1`. Radius to use when calculating the SSAO term.}

\item{tonemap}{Default `"none"`.}

\item{debug}{Default `"none"`.}

\item{near_plane}{Default `0.1`.}

\item{far_plane}{Default `100`.}

\item{culling}{Default `"back"`.}

\item{shader}{Default `"default"`.}

\item{block_size}{Default `4`.}

\item{shape}{Default `NULL`. The shape to render in the OBJ mesh.}

\item{...}{Other parameters to pass to `rasterize_mesh()`.}
}
\value{
Rasterized image.
}
\description{
Rasterize an OBJ file
}
\examples{
#Let's load the cube OBJ file included with the package

cube_model = read_obj(cube_obj())

rasterize_mesh(cube_model,lookfrom=c(2,4,10), 
              light_info = directional_light(direction=c(0.5,1,0.7)))

#Flatten the cube, translate downwards, and set to grey
base_model = cube_model \%>\% 
 scale_mesh(scale=c(5,0.2,5)) \%>\%
 translate_mesh(c(0,-0.1,0)) \%>\% 
 set_material(diffuse="grey80") 

rasterize_mesh(base, lookfrom=c(2,4,10), 
              light_info = directional_light(direction=c(0.5,1,0.7)))

#load the R OBJ file, scale it down, color it blue, and add it to the grey base
r_model = r_obj() \%>\% 
 read_obj() \%>\% 
 scale_mesh(scale=0.5) \%>\% 
 set_material(diffuse="dodgerblue") \%>\% 
 add_shape(base_model)

rasterize_mesh(r_model, lookfrom=c(2,4,10), 
              light_info = directional_light(direction=c(0.5,1,0.7)))
              
#Zoom in and turn on shadow mapping
rasterize_mesh(r_model, lookfrom=c(2,4,10), fov=10,shadow_map = TRUE,
              light_info = directional_light(direction=c(0.5,1,0.7)))

#Include the resolution (4x) of the shadow map for less pixellation around the edges
#Also decrease the shadow_map_bias slightly to remove the "peter panning" floating shadow effect
rasterize_mesh(r_model, lookfrom=c(2,4,10), fov=10,
              shadow_map = TRUE, shadow_map_dims=4, shadow_map_bias=0.001,
              light_info = directional_light(direction=c(0.5,1,0.7)))
              
#Add some more directional lights and change their color
lights = directional_light(c(0.7,1.1,-0.9),color = "orange",intensity = 1) \%>\% 
           add_light(directional_light(c(0.7,1,1),color = "dodgerblue",intensity = 1)) \%>\% 
           add_light(directional_light(c(2,4,10),color = "white",intensity = 0.5))
           
rasterize_mesh(r_model, lookfrom=c(2,4,10), fov=10,
              shadow_map = TRUE, shadow_map_dims=4, shadow_map_bias=0.001,
              light_info = lights)
              
#Add some point lights
lights_p = lights \%>\% 
 add_light(point_light(position=c(-1,1,0),color="red", intensity=10)) \%>\% 
 add_light(point_light(position=c(1,1,0),color="purple", intensity=10)) 

rasterize_mesh(r_model, lookfrom=c(2,4,10), fov=10,
              shadow_map = TRUE, shadow_map_dims=4, shadow_map_bias=0.001,
              light_info = lights_p)
              
#change the camera position
rasterize_mesh(r_model, lookfrom=c(-2,2,-10), fov=10,
              shadow_map = TRUE, shadow_map_dims=4, shadow_map_bias=0.001,
              light_info = lights_p)
              
#Add a spiral of lines around the model by generating a matrix of line segments
#Each pair of rows represent a single segment. Lines are ignored by shadows.
t = seq(0,8*pi,length.out=361)

line_mat = matrix(0,nrow=720,ncol=3)
for(i in 1:360) {
line_mat[(2*i-1),] = c(0.5*sin(t[i]), t[i]/(8*pi), 0.5*cos(t[i]))
line_mat[(2*i),]   = c(0.5*sin(t[i+1]), t[i+1]/(8*pi), 0.5*cos(t[i+1]))
}

rasterize_mesh(r_model, lookfrom=c(2,4,10), fov=10, line_info = line_mat,
              shadow_map = TRUE, shadow_map_dims=4, shadow_map_bias=0.001,
              light_info = lights)
}
